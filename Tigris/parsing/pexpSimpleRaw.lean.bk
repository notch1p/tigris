import Tigris.utils
import Tigris.typing.types

namespace Parsing.Raw open RawExpr RawPattern Lexing Pattern Parser

mutual
partial def rawPatternAtom : TParser RawPattern := ws $
      kw "_" $> atom PWild
  <|> (do
        let id <- ID
        if isUpperInit id then
          return atom (PCtor id #[])
        else
          return atom (PVar id))
  <|> parenthesized rawPattern

partial def rawPattern : TParser RawPattern := ws do
  let hd <- rawPatternAtom
  let tl <- takeMany $ (路 , 路) <$> opSym <*> rawPatternAtom
  if tl.isEmpty then return hd
  else return chain hd tl
end

mutual

partial def rawExpr := ws $ chainl1 rawAtom (pure App)

partial def rawAtom : TParser RawExpr := ws do
  first' #[ parenthesized rawProd
          , CI <$> intLit, CS <$> strLit
          , do ID <&> fun | "true" => CB true | "false" => CB false | id => Var id
          , rawFun, rawLet, rawFix, rawCond, rawMatch]

partial def rawProd  : TParser RawExpr := ws do
  let es <- sepBy COMMA rawExpr
  return match h : es.size with
         | 0 => CUnit
         | 1 => es[0]
         | _ + 2 => es[0:es.size - 1].foldr Prod' es[es.size - 1]

partial def rawFun   : TParser RawExpr := ws do
  FUN; let args <- takeMany1 ID
  ARROW; let body <- rawExpr
  return args.foldr Fun body
partial def rawLet   : TParser RawExpr := ws do
  LET; let rec? <- test REC
  let id <- ID
  let args <- takeMany ID
  EQ; let rhs <- rawExpr
  IN; let body <- rawExpr
  let fn := args.foldr Fun rhs
  return if rec? then Let id (Fix fn) body
                 else Let id fn body
partial def rawFix   : TParser RawExpr := ws do
  REC; 
  option? rawExpr <&> fun
                      | none => Var "rec"
                      | some e => (Fixcomb e)
partial def rawCond  : TParser RawExpr := ws do
  IF;   let c <- rawExpr
  THEN; let t <- rawExpr
  ELSE; let e <- rawExpr
  return Cond c t e

partial def rawMatch : TParser RawExpr := ws do
  MATCH let e <- rawExpr; WITH
  let hd <- optional BAR *> rawBranch
  let tl <- takeMany $ BAR *> rawBranch
  return Match e $ #[hd] ++ tl
where
  rawBranch := do
    let p <- rawPattern; ARROW; let e <- rawExpr
    return (p, e)

end
def rawChain : TParser RawExpr := ws do
  let hd <- rawExpr;
  let tl <- takeMany $ (路 , 路) <$> opSym <*> rawExpr
  if tl.isEmpty then return hd
  else return Chain hd tl

end Parsing.Raw

#eval Parsing.Raw.rawChain "f of! b"
