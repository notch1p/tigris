class Functor (f : 1) =
  {map : forall a b, (a -> b) -> f a -> f b}
class Applicative (f : 1) =
  { pure : ∀ a, a -> f a
    -- lazy to preserve eval semantics
  , seq : ∀a b, f (a -> b) -> (Unit -> f a) -> f b
  }
class Monad (m : 1) =
  { bind : ∀a b, m a -> (a -> m b) -> m b
  , return : ∀a, a -> m a}

infixl 55 ">>=" => bind

instance ∀(m : 1) [Monad m], Applicative m =
  { pure = return
  , seq f x = f >>= fun f => x () >>= fun x => return $ f x
  }
instance ∀(f : 1) [Applicative f], Functor f =
  {map f x = seq (pure f) fun _ => x}

type Option a = None | Some a

instance Applicative Option =
   { pure = Some
   , seq
     | None, x => None
     | Some f, x =>
       match x () with
       | None => None
       | Some x => Some (f x) }
instance Monad Option =
  { return = Some
  , bind
    | None, _ => None
    | Some x, f => f x}
let id x = x
let bindOp = (bind : ∀a b, Option a -> (a -> Option b) -> Option b)
let seqOp = seq (Some id)
  -- uses the first instance, instead of the most specific one.

---------------- SysF IR ----------------

let (>>=) : ∀ α [Monad α], ∀ a b, α a → (a → α b) → α b =
  (Λ α. fun d_Monad_0 : Monad α => (Λ a b. d_Monad_0[0, bind]@α))

let i_Applicative_0 : ∀ m [Monad m], Applicative m =
  (Λ m.
     fun d_Monad_0 : Monad m =>
       Applicative@m
         (Λ a.
            d_Monad_0[1, return]@m)
         (Λ a b.
            fun f : m (a → b) =>
              fun x : Unit → m a =>
                d_Monad_0[0, bind]@m
                  f
                  (fun f : a → b =>
                     d_Monad_0[0, bind]@m
                       (x ()) (fun x : a => d_Monad_0[1, return]@m (f x)))))

let i_Functor_0 : ∀ f [Applicative f], Functor f =
  (Λ f.
     fun d_Applicative_0 : Applicative f =>
       Functor@f
         (Λ a b.
            fun f : a → b =>
              fun x : f a =>
                d_Applicative_0[1, seq]@f
                  (d_Applicative_0[0, pure]@f f) (fun _ : Unit => x)))

let i_Applicative_1 : Applicative Option =
  Applicative@Option
    (Λ a.
       Some@a)
    (Λ a b.
       fun ?x₀ : Option (a → b) =>
         fun ?x₁ : Unit → Option a =>
           match ?x₀, ?x₁ with
           | None, x => None@b
           | Some f, x =>
             match x () with | None => None@b | Some x => Some@b (f x))

let i_Monad_0 : Monad Option =
  Monad@Option
    (Λ a b.
       fun ?x₀ : Option a =>
         fun ?x₁ : a → Option b =>
           match ?x₀, ?x₁ with
           | None, _ => None@b
           | Some x, f => f x) (Λ a. Some@a)

let id : ∀ α, α → α = (Λ α. fun x : α => x)

let bindOp : ∀ α β, Option α → (α → Option β) → Option β =
  let rd_Monad_0 : Monad Option = i_Monad_0
  in (Λ α β. rd_Monad_0[0, bind]@Option)

let seqOp : ∀ α, (Unit → Option α) → Option α =
  let rd_Applicative_1 : Applicative Option =
    let rd_Monad_0 : Monad Option = i_Monad_0
    in i_Applicative_0@Option rd_Monad_0
  in (Λ α. rd_Applicative_1[1, seq]@Option (Some@(α → α) id@α))

